<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Schema Stitching · Hot Chocolate</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;p&gt;&lt;strong&gt;What is schema stitching actually?&lt;/strong&gt;&lt;/p&gt;
"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Schema Stitching · Hot Chocolate"/><meta property="og:type" content="website"/><meta property="og:url" content="https://hotchocolate.io/index.html"/><meta property="og:description" content="&lt;p&gt;&lt;strong&gt;What is schema stitching actually?&lt;/strong&gt;&lt;/p&gt;
"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://hotchocolate.io/img/cupcake.png"/><link rel="shortcut icon" href="/img/favicon.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atelier-dune-light.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-72800164-3', 'auto');
              ga('send', 'pageview');
            </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster:700,400"/><link rel="stylesheet" href="/css/code-block-buttons.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script><script type="text/javascript" src="/js/code-block-buttons.js"></script><script src="https://unpkg.com/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/signet.svg" alt="Hot Chocolate"/><h2 class="headerTitleWithLogo">Hot Chocolate</h2></a><a href="/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/next/introduction" target="_self">Docs</a></li><li class=""><a href="/docs/next/example-star-wars-code-first" target="_self">Examples</a></li><li class=""><a href="https://chillicream.com/blog" target="_blank">Blog</a></li><li class=""><a href="https://github.com/ChilliCream/hotchocolate" target="_blank">GitHub</a></li><li class=""><a target="_self"></a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>API Reference</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Introduction<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/introduction">Introduction</a></li><li class="navListItem"><a class="navItem" href="/docs/next/code-first">Code-first</a></li><li class="navListItem"><a class="navItem" href="/docs/next/schema-first">Schema-first</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">API Reference<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/custom-scalar-types">Scalar Type Support</a></li><li class="navListItem"><a class="navItem" href="/docs/next/dataloaders">Data Loaders</a></li><li class="navListItem"><a class="navItem" href="/docs/next/pagination">Pagination</a></li><li class="navListItem"><a class="navItem" href="/docs/next/dependency-injection">Dependency Injection</a></li><li class="navListItem"><a class="navItem" href="/docs/next/authorization">Authorization</a></li><li class="navListItem"><a class="navItem" href="/docs/next/middleware">Middleware</a></li><li class="navListItem"><a class="navItem" href="/docs/next/custom-context">Custom Context Data</a></li><li class="navListItem"><a class="navItem" href="/docs/next/options">Options</a></li><li class="navListItem"><a class="navItem" href="/docs/next/type-conversion">Type Conversion</a></li><li class="navListItem"><a class="navItem" href="/docs/next/aspnet">ASP.net</a></li><li class="navListItem"><a class="navItem" href="/docs/next/parser">Parser</a></li><li class="navListItem"><a class="navItem" href="/docs/next/errors">Error Filter</a></li><li class="navListItem"><a class="navItem" href="/docs/next/security">Security</a></li><li class="navListItem"><a class="navItem" href="/docs/next/validation-rule">Validation Rules</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/next/stitching">Schema Stitching</a></li><li class="navListItem"><a class="navItem" href="/docs/next/instrumentation">Instrumentation</a></li><li class="navListItem"><a class="navItem" href="/docs/next/apollo-tracing">Apollo Tracing</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">Guides<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/migration">Migrating from 0.6.x</a></li><li class="navListItem"><a class="navItem" href="/docs/next/dotnet-cli">.NET CLI</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/ChilliCream/hotchocolate-docs/edit/master/docs/stitching.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 class="postHeaderTitle">Schema Stitching</h1></header><article><div><span><p><strong>What is schema stitching actually?</strong></p>
<p>Schema stitching is the capability to merge multiple GraphQL schemas into one schema that can be queried.</p>
<h2><a class="anchor" aria-hidden="true" id="introduction"></a><a href="#introduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Introduction</h2>
<p><strong>So, for what is that useful?</strong></p>
<p>In our case we have lots of specialized services that serve data for specific problem domains. Some of these services are GraphQL services, some of them are REST services and yes sadly a little portion of those are still SOAP services.</p>
<p>With <em>Hot Chocolate</em> schema stitching you are able to create a gateway that bundles all those services into one GraphQL schema.</p>
<p><strong>Is schema stitching basically just putting two schemas together?</strong></p>
<p>Just putting two schemas into one and avoid name collisions is simple. But what we want to achieve with schema stitching is one consistent schema.</p>
<p><em>Hot Chocolate</em> schema stitching allows us to really integrate services into one schema by folding types into one another and even renaming or removing parts.</p>
<p>With this we can create a consistent GraphQL schema that hides the implementation details of our backend services and provides the consumer of our endpoint with the capability to fetch the data they need with one call, no under- or over-fetching and most importantly no repeated fetching because you first needed to fetch that special id with which you now can then fetch this other thingy.</p>
<h2><a class="anchor" aria-hidden="true" id="getting-started"></a><a href="#getting-started" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting Started</h2>
<p>In order to showcase how schema stitching works and what the problems are let us assume we have a service like twitter, where a user can post messages.</p>
<p>Moreover, let us assume we have three teams working on internal micro-/domain-services that handle certain aspects of that service.</p>
<p>The first service is handling the message stream and has the following schema:</p>
<pre><code class="hljs css language-graphql">type Query {
  messages(userId: ID!): [Message!]
  message(messageId: ID!): Message
}
<span class="hljs-built_in">
type </span>Mutation {
  newMessage(input: NewMessageInput!): NewMessagePayload!
}
<span class="hljs-built_in">
type </span>Message {
  id: ID!
  text: String!
  createdBy: ID!
  createdAt: DateTime!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessageInput {
  text: String!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessagePayload {
  message: Message
}
</code></pre>
<p>The second service is handling the users of the services and has the following schema:</p>
<pre><code class="hljs css language-graphql">type Query {
  user(userId: ID!): User!
  users: [User!]
}
<span class="hljs-built_in">
type </span>Mutation {
  newUser(input: NewUserInput!): NewUserPayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
}
<span class="hljs-built_in">
type </span>NewUserInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>ResetPasswordInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>NewUserPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type </span>ResetPasswordPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type User </span>{
  id: ID!
  username: String!
}
</code></pre>
<p>Last but not least we have a third service handling the message analytics. In our example case we keep it simple and our analytics services just tracks three different counters per message. The schema for this service looks like the following:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-keyword">type</span> Query {
  analytics(<span class="hljs-symbol">messageId:</span> ID!, <span class="hljs-symbol">type:</span> CounterType!): MessageAnalytics
}

<span class="hljs-keyword">type</span> MessageAnalytics {
  <span class="hljs-symbol">id:</span> ID!
  <span class="hljs-symbol">messageId:</span> ID!
  <span class="hljs-symbol">count:</span> Int!
  <span class="hljs-symbol">type:</span> CounterType!
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CounterType</span> {</span>
  VIEWS
  LIKES
  REPLIES
}
</code></pre>
<p>With those three separate schemas our UI team would have to fetch from multiple endpoints.</p>
<p>Even worse for our UI team, in order to build a stream view that shows the message text and the name of the user who posted the message, they would have to first fetch all the messages and could only then fetch the names of the users.</p>
<p>This is actually one of the very things GraphQL tries to solve.</p>
<h2><a class="anchor" aria-hidden="true" id="setting-up-our-server"></a><a href="#setting-up-our-server" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Setting up our server</h2>
<p>Before we start with stitching itself let`s get into how to setup our server.</p>
<p>Every <em>Hot Chocolate</em> server can be a stitching server. This means in order to get started we can just use the <em>Hot Chocolate</em> GraphQL server template and modify it a little bit to make the server a stitching server.</p>
<p>If you do not have the <em>Hot Chocolate</em> GraphQL server template installed execute first the following command.</p>
<pre><code class="hljs css language-bash">dotnet new -i HotChocolate.Templates.Server
</code></pre>
<p>After that we will create a new folder and add a new server to that folder.</p>
<pre><code class="hljs css language-bash">mkdir stitching-demo
<span class="hljs-built_in">cd</span> stitching-demo
dotnet new graphql-server
</code></pre>
<p>With this we have now a functioning GraphQL server with a simple hello world example.</p>
<p>In order to make this server a stitching server we now have to add the <em>Hot Chocolate</em> stitching engine.</p>
<pre><code class="hljs css language-bash">dotnet add package HotChocolate.Stitching
</code></pre>
<p>Now that our GraphQL server is ready we can start to configure the endpoints of our remote schemas.</p>
<blockquote>
<p>Remote schemas are what we call the GraphQL schemas that we want include into our merged schema. Remote schemas can be any GraphQL Spec compliant server (Apollo, Sangria, etc.) that serves its schema up over HTTP. Also we can include local schemas that we have created with the <em>Hot Chocolate</em> .net API.</p>
</blockquote>
<p>The endpoints are declared by using a named <code>HttpClient</code> via the HttpClient factory that is included with ASP.net core.</p>
<pre><code class="hljs css language-csharp">services.AddHttpClient(<span class="hljs-string">"messages"</span>, (sp, client) =&gt;
{
  client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"http://127.0.0.1:5050"</span>);
});
services.AddHttpClient(<span class="hljs-string">"users"</span>, (sp, client) =&gt;
{
  client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"http://127.0.0.1:5051"</span>);
});
services.AddHttpClient(<span class="hljs-string">"analytics"</span>, (sp, client) =&gt;
{
  client.BaseAddress = <span class="hljs-keyword">new</span> Uri(<span class="hljs-string">"http://127.0.0.1:5052"</span>);
});
</code></pre>
<p>Now let`s remove the parts from the server template that we don't need.</p>
<blockquote>
<p>We will show how some strategies of how to handle authenticated services later on.</p>
</blockquote>
<pre><code class="hljs css language-csharp">services.AddDataLoaderRegistry();

services.AddGraphQL(sp =&gt; Schema.Create(c =&gt;
{
    c.RegisterQueryType&lt;Query&gt;();
}));
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="stitching-builder"></a><a href="#stitching-builder" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stitching Builder</h2>
<p>The stitching builder is the main API to configure a stiched GraphQL schema. In order to have a simple automerge we have just to provide all the necessary schema names and the stitching layer will fetch the remote schemas via introspection on the first call to the stitched schema.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>));
</code></pre>
<p>Since a stitched schema is the same then any other GraphQL schema we can configure custom types, custom middleware or other things with it.</p>
<p>In our example we are stitching together schemas that come with non-spec scalar types like <code>DateTime</code>. So, the stitching layer would report an error when stitching the above three schemas together since the <code>DateTime</code> scalar is unknown.</p>
<p>In order to declare this custom scalar we can register the extended scalar set like with a regular <em>Hot Chocolate</em> GraphQL schema through the <code>AddSchemaConfiguration</code>-method on the stitching builder.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>))
  .AddSchemaConfiguration(c =&gt;
  {
    c.RegisterExtendedScalarTypes();
  })
</code></pre>
<blockquote>
<p>For more information about our scalars can be found <a href="/docs/next/custom-scalar-types">here</a>.</p>
</blockquote>
<p>With this in place our schema now looks like the following:</p>
<pre><code class="hljs css language-graphql">type Query {
  messages(userId: ID!): [Message!]
  message(messageId: ID!): Message
  user(userId: ID!): User!
  users: [User!]
  analytics(messageId: ID!, type: CounterType!): MessageAnalytics
}
<span class="hljs-built_in">
type </span>Mutation {
  newMessage(input: NewMessageInput!): NewMessagePayload!
  newUser(input: NewUserInput!): NewUserPayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
}
<span class="hljs-built_in">
type </span>Message {
  id: ID!
  text: String!
  createdBy: ID!
  createdAt: DateTime!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessageInput {
  text: String!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessagePayload {
  message: Message
}
<span class="hljs-built_in">
type </span>NewUserInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>ResetPasswordInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>NewUserPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type </span>ResetPasswordPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type User </span>{
  id: ID!
  username: String!
}
<span class="hljs-built_in">
type </span>MessageAnalytics {
  id: ID!
  messageId: ID!
  count: Int!
  type: CounterType!
}

enum CounterType {
  VIEWS
  LIKES
  REPLIES
}
</code></pre>
<p>We just achieved a simple schema merge without doing a lot. But honostly we would like to change some of the details. While the stitching result is nice what we want to do is to integrate it much more.</p>
<h3><a class="anchor" aria-hidden="true" id="extending-types"></a><a href="#extending-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extending Types</h3>
<p>So, the first thing that we would like to have is a new field on the query that is called <code>me</code>. The <code>me</code> fields should be the currently signed in user.</p>
<p>Further, the user type should expose the message stream of the user, this way we could fetch the messages of the signed in user like the following:</p>
<pre><code class="hljs css language-graphql">{
  me {
    messages {
      text
      tags
    }
  }
}
</code></pre>
<p>In order to extend types in a stitched schema we can use the new GraphQL extend syntax that was introuced with the 2018 spec.</p>
<pre><code class="hljs css language-graphql"><span class="hljs-selector-tag">extend</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">Query</span> {
  <span class="hljs-attribute">me</span>: User! <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"users"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"user(id: $contextData:UserId)"</span>)
}

<span class="hljs-selector-tag">extend</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">User</span> {
  <span class="hljs-attribute">messages</span>: [Message!]
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"messages"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"messages(userId: $fields:Id)"</span>)
}
</code></pre>
<p>With just that and no further code needed we have specified how the GraphQL stitching engine shall rewrite our schema.</p>
<p>Let us disect the above GraphQL SDL in order to understand what just happend.</p>
<p>First, let us have a look at the <code>Query</code> extensions. We declared a the field like we would do it in a schema-first approach. After that we annotated the field with the <code>delegate</code> directive. The delegate directive basically works like a middleware that will create a fetch on the specified schema.</p>
<p>The <code>path</code>-argument on the <code>delegate</code> directive specifies how to fetch the data. The selection path can have multiple levels. So if you wanted to fetch just the username you could do that like the following:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-function"><span class="hljs-title">user</span><span class="hljs-params">(id: <span class="hljs-variable">$contextData</span>:UserId)</span></span><span class="hljs-selector-class">.username</span>
</code></pre>
<p>Moreover, we are using a special variable that can access the resolver context. Currently this variable has four scopes:</p>
<ul>
<li><p>Arguments</p>
<p>Access arguments of the field: <code>$arguments:ArgumentName</code></p></li>
<li><p>Fields</p>
<p>Access fields of the declaring type: <code>$fields:FieldName</code></p></li>
<li><p>ContextData</p>
<p>Access properties of the request context data map: <code>$contextData:Key</code></p></li>
<li><p>ScopedContextData</p>
<p>Access properties of the scoped field context data map: <code>$contextData:Key</code></p></li>
</ul>
<p>The context data can be used to map custom properties into our GraphQL resolvers. In our case we will use it to map the internal user ID from the user claims into our context data map. This allows us to have some kind of abstraction between the actual HttpRequest and the data that is needed to process a GraphQL request.</p>
<blockquote>
<p>We have documentation on how to add custom context data from your http request <a href="/docs/next/custom-context">here</a></p>
</blockquote>
<p>OK, lets sum this up, with the <code>delegate</code> directive we are able to create powerfull stitching resolver without writing one line of c# code. We, are able to create powerful new types that make the API so much richer.</p>
<p>In order to get our extensions integrated we need to add the extensions to our stitching builder. Like with the schema we have multiple extension methods to load the GraphQL SDL from a file or a string etc.</p>
<p>In our case lets say we are loading int from a file called <code>Extensions.graphql</code>.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>))
  .AddExtensionsFromFile(<span class="hljs-string">"./graphql/Extensions.graphql"</span>)
  .AddSchemaConfiguration(c =&gt;
  {
    c.RegisterExtendedScalarTypes();
  })
</code></pre>
<p>No with all of this in place we our schema now looks like the following:</p>
<pre><code class="hljs css language-graphql">type Query {
  me: User!
  messages(userId: ID!): [Message!]
  message(messageId: ID!): Message
  user(userId: ID!): User!
  users: [User!]
  analytics(messageId: ID!, type: CounterType!): MessageAnalytics
}
<span class="hljs-built_in">
type </span>Mutation {
  newMessage(input: NewMessageInput!): NewMessagePayload!
  newUser(input: NewUserInput!): NewUserPayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
}
<span class="hljs-built_in">
type </span>Message {
  id: ID!
  text: String!
  createdBy: ID!
  createdAt: DateTime!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessageInput {
  text: String!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessagePayload {
  message: Message
}
<span class="hljs-built_in">
type </span>NewUserInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>ResetPasswordInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>NewUserPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type </span>ResetPasswordPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type User </span>{
  id: ID!
  username: String!
  messages: [Message!]
}
<span class="hljs-built_in">
type </span>MessageAnalytics {
  id: ID!
  messageId: ID!
  count: Int!
  type: CounterType!
}

enum CounterType {
  VIEWS
  LIKES
  REPLIES
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="renaming-and-removing-types"></a><a href="#renaming-and-removing-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Renaming and Removing Types</h3>
<p>Though this is nice we would like to go even further. We would like now to enhance our <code>Message</code> type like the following:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-keyword">type</span> <span class="hljs-type">Message</span> {
  id: <span class="hljs-type">ID</span>!
  text: <span class="hljs-type">String</span>!
  createdBy: <span class="hljs-type">User</span>
  createdById: <span class="hljs-type">ID</span>!
  createdAt: <span class="hljs-type">DateTime</span>!
  tags: [<span class="hljs-type">String</span>!]
  views: <span class="hljs-type">Int</span>!
  likes: <span class="hljs-type">Int</span>!
  replies: <span class="hljs-type">Int</span>!
}
</code></pre>
<p>Moreover, we would like to remove the <code>analytics</code> field from our query type since we have integrated the analytics data into our <code>Message</code> type. Moreover, since with the root field gone we have no way to access <code>MessageAnalytics</code> and <code>CounterType</code> lets also get rid of these types.</p>
<p>The stitching builder has powerfull refactoring functions for your schemas that can even be extended by writing custom rewriters. In order to remove a field or a type we can tell the stitching builder to ignore them.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>))
  .AddExtensionsFromFile(<span class="hljs-string">"./graphql/Extensions.graphql"</span>)
  .IgnoreField(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"Query"</span>, <span class="hljs-string">"analytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"MessageAnalytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"CounterType"</span>)
  .AddSchemaConfiguration(c =&gt;
  {
    c.RegisterExtendedScalarTypes();
  })
</code></pre>
<blockquote>
<p>There are also methods for renaming types and fields where the stitching engine will take care that the schema is consitently rewritten so that all the type references will refer to the corrent type/field name.</p>
</blockquote>
<p>With that we have remove the types from our stitched schema. No, let us move on to extend our message type.</p>
<pre><code class="hljs css language-graphql"><span class="hljs-selector-tag">extend</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">Message</span> {
  <span class="hljs-attribute">createdBy</span>: User!
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"users"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"user(id: $fields:createdById)"</span>)
  <span class="hljs-attribute">views</span>: Int! <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
  <span class="hljs-attribute">likes</span>: Int! <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
  <span class="hljs-attribute">replies</span>: Int!
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
}
</code></pre>
<p>Also we need to rename the field <code>createdBy</code> to <code>createdById</code>.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>))
  .AddExtensionsFromFile(<span class="hljs-string">"./graphql/Extensions.graphql"</span>)
  .IgnoreField(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"Query"</span>, <span class="hljs-string">"analytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"MessageAnalytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"CounterType"</span>)
  .RenameField(<span class="hljs-string">"messages"</span>, <span class="hljs-string">"Message"</span>, <span class="hljs-string">"createdBy"</span>, <span class="hljs-string">"createdById"</span>)
  .AddSchemaConfiguration(c =&gt;
  {
    c.RegisterExtendedScalarTypes();
  })
</code></pre>
<blockquote>
<p>It is important to now that the schema rewriters are executed before the schemas are merged and the extensions integrated.</p>
</blockquote>
<p>Our new schema now looks like the following:</p>
<pre><code class="hljs css language-graphql">type Query {
  me: User!
  messages(userId: ID!): [Message!]
  message(messageId: ID!): Message
  user(userId: ID!): User!
  users: [User!]
}
<span class="hljs-built_in">
type </span>Mutation {
  newMessage(input: NewMessageInput!): NewMessagePayload!
  newUser(input: NewUserInput!): NewUserPayload!
  resetPassword(input: ResetPasswordInput!): ResetPasswordPayload!
}
<span class="hljs-built_in">
type </span>Message {
  id: ID!
  text: String!
  createdBy:<span class="hljs-built_in"> User
</span>  createdById: ID!
  createdAt: DateTime!
  tags: [String!]
  views: Int!
  likes: Int!
  replies: Int!
}
<span class="hljs-built_in">
type </span>NewMessageInput {
  text: String!
  tags: [String!]
}
<span class="hljs-built_in">
type </span>NewMessagePayload {
  message: Message
}
<span class="hljs-built_in">
type </span>NewUserInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>ResetPasswordInput {
  username: String!
  password: String!
}
<span class="hljs-built_in">
type </span>NewUserPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type </span>ResetPasswordPayload {
  user:<span class="hljs-built_in"> User
</span>}
<span class="hljs-built_in">
type User </span>{
  id: ID!
  username: String!
  messages: [Message!]
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="query-rewriter"></a><a href="#query-rewriter" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Query Rewriter</h3>
<p>As you can see it is quite simple to stitch multiple schemas together and enhance them with the stitching builder.</p>
<p><strong>But how can we go further and hook into the query rewriter of the stitching engine?</strong></p>
<p>Let us for instance try to get rid of the <code>createdById</code> field of the <code>Message</code> type.</p>
<p>We actually need this field in order to fetch the <code>User</code> from the remote schema. In order to be able to remove this field, we would need to be able to request it as some kind of a hidden field whenever a <code>Message</code> object is resolved.</p>
<p>We could then write a little field middleware that copies us the hidden field data into our scoped conetext data, so that we are consequently able to use the id in our <code>delegate</code> directive.</p>
<p>The stitching engine allows us to hook into the the query rewrite process and add our own rewrite logic that could add fields or even large sub-queries.</p>
<p>The first thing we need to do here is to create a new class that inherits from <code>QueryDelegationRewriterBase</code>.</p>
<p>The base class exposes two virtual methods <code>OnRewriteField</code> and <code>OnRewriteSelectionSet</code>.</p>
<p>A selection set describes a selection of fields and fragments on a certain type.</p>
<p>So, in order to fetch a hidden field every time a ceratain type is requested we would want to overwrite <code>OnRewriteSelectionSet</code>.</p>
<pre><code class="hljs css language-csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AddCreatedByIdQueryRewriter</span>
    : <span class="hljs-title">QueryDelegationRewriterBase</span>
{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> SelectionSetNode <span class="hljs-title">OnRewriteSelectionSet</span>(<span class="hljs-params">
        NameString targetSchemaName,
        IOutputType outputType,
        IOutputField outputField,
        SelectionSetNode selectionSet</span>)</span>
    {
        <span class="hljs-keyword">if</span>(outputType.NamedType() <span class="hljs-keyword">is</span> ObjectType objectType
          &amp;&amp; objectType.Name.Equals(<span class="hljs-string">"Message"</span>))
        {
            <span class="hljs-keyword">return</span> selectionSet.AddSelection(
                <span class="hljs-keyword">new</span> FieldNode
                (
                    <span class="hljs-literal">null</span>,
                    <span class="hljs-keyword">new</span> NameNode(<span class="hljs-string">"createdBy"</span>),
                    <span class="hljs-keyword">new</span> NameNode(<span class="hljs-string">"createdById"</span>),
                    Array.Empty&lt;DirectiveNode&gt;(),
                    Array.Empty&lt;ArgumentNode&gt;(),
                    <span class="hljs-literal">null</span>
                ));
        }

        <span class="hljs-keyword">return</span> selectionSet;
    }
}
</code></pre>
<p>The syntax nodes have a lot of little rewrite helpers like <code>AddSelection</code>. These helper methods basically branch of the syntax tree and return a new version that contains the applied change. In our case we get a new <code>SelectionSetNode</code> that now also contains a field <code>createdBy</code> with an alias <code>createdById</code>. In a real-world implementations you should use a more complex alias name like <code>___internal_field_createdById</code> in order to avoid collisions with field selections of the query.</p>
<p>Query delegation rewriters are registered with the dependency injection and not with our stitching builder.</p>
<pre><code class="hljs css language-csharp">services.AddQueryDelegationRewriter&lt;AddCreatedByIdQueryRewriter&gt;();
</code></pre>
<blockquote>
<p>Query delegation rewriters are hosted as scoped services and you can be injected <code>IStitchingContext</code> and <code>ISchema</code> in order to access the remote schemas or the stitched schema for advanced type information.</p>
</blockquote>
<p>With that setup the stitching engine will always fetch the requested field for us when a <code>Message</code> object is requested.</p>
<p>So, now let us move on to write a little middleware that copies this data into our scoped resolver context data map. The data in this map will only be available to the resolvers in the subtree of the message type.</p>
<p>A field middleware has to be declared via the stitching builder.</p>
<pre><code class="hljs css language-csharp">services.AddStitchedSchema(builder =&gt; builder
  .AddSchemaFromHttp(<span class="hljs-string">"messages"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"users"</span>)
  .AddSchemaFromHttp(<span class="hljs-string">"analytics"</span>))
  .AddExtensionsFromFile(<span class="hljs-string">"./graphql/Extensions.graphql"</span>)
  .IgnoreField(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"Query"</span>, <span class="hljs-string">"analytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"MessageAnalytics"</span>)
  .IgnoreType(<span class="hljs-string">"analytics"</span>, <span class="hljs-string">"CounterType"</span>)
  .IgnoreField(<span class="hljs-string">"messages"</span>, <span class="hljs-string">"Message"</span>, <span class="hljs-string">"createdBy"</span>)
  .AddSchemaConfiguration(c =&gt;
  {
    c.RegisterExtendedScalarTypes();

    c.Use(next =&gt; <span class="hljs-keyword">async</span> context =&gt;
    {
        <span class="hljs-keyword">await</span> next.Invoke(context);

        <span class="hljs-keyword">if</span>(context.Field.Type.NamedType() <span class="hljs-keyword">is</span> ObjectType objectType
          &amp;&amp; objectType.Name.Equals(<span class="hljs-string">"Message"</span>)
          &amp;&amp; context.Result <span class="hljs-keyword">is</span> IDictionary&lt;<span class="hljs-keyword">string</span>, <span class="hljs-keyword">object</span>&gt; data
          &amp;&amp; data.TryGetValue(<span class="hljs-string">"createdById"</span>, <span class="hljs-keyword">out</span> <span class="hljs-keyword">object</span> <span class="hljs-keyword">value</span>))
        {
            context.ScopedContextData =
                context.ScopedContextData.SetItem(<span class="hljs-string">"createdById"</span>, <span class="hljs-keyword">value</span>);
        }
    })
  })
</code></pre>
<blockquote>
<p>We could also declare a field middleware as class. More about what you can do with a field middleware can be found <a href="/docs/next/middleware">here</a>.</p>
</blockquote>
<p>With all of this in place we could now rewrite our <code>Message</code> type extension and access the <code>createdById</code> from the scoped context data:</p>
<pre><code class="hljs css language-graphql"><span class="hljs-selector-tag">extend</span> <span class="hljs-selector-tag">type</span> <span class="hljs-selector-tag">Message</span> {
  <span class="hljs-attribute">createdBy</span>: User!
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"users"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"user(id: $scopedContextData:createdById)"</span>)
  <span class="hljs-attribute">views</span>: Int! <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
  <span class="hljs-attribute">likes</span>: Int! <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
  <span class="hljs-attribute">replies</span>: Int!
    <span class="hljs-variable">@delegate</span>(<span class="hljs-attribute">schema</span>: <span class="hljs-string">"analytics"</span>, <span class="hljs-attribute">path</span>: <span class="hljs-string">"analytics(id: $fields:id)"</span>)
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="validating-a-stitched-schema"></a><a href="#validating-a-stitched-schema" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Validating a Stitched Schema</h3>
<h3><a class="anchor" aria-hidden="true" id="customizing-stitching-builder"></a><a href="#customizing-stitching-builder" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Customizing Stitching Builder</h3>
<h2><a class="anchor" aria-hidden="true" id="authentication"></a><a href="#authentication" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Authentication</h2>
<h2><a class="anchor" aria-hidden="true" id="batching"></a><a href="#batching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Batching</h2>
<h2><a class="anchor" aria-hidden="true" id="root-types"></a><a href="#root-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Root Types</h2>
<p>We are currently supporting stitching <code>Query</code> and <code>Mutation</code>. With Version 9 we will introduce stitching the <code>Subscription</code> type.</p>
</span></div></article></div><div class="docLastUpdate"><em>Last updated on 2019-3-4 by Michael Staib</em></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/next/validation-rule"><span class="arrow-prev">← </span><span>Validation Rules</span></a><a class="docs-next button" href="/docs/next/instrumentation"><span>Instrumentation</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#introduction">Introduction</a></li><li><a href="#getting-started">Getting Started</a></li><li><a href="#setting-up-our-server">Setting up our server</a></li><li><a href="#stitching-builder">Stitching Builder</a><ul class="toc-headings"><li><a href="#extending-types">Extending Types</a></li><li><a href="#renaming-and-removing-types">Renaming and Removing Types</a></li><li><a href="#query-rewriter">Query Rewriter</a></li><li><a href="#validating-a-stitched-schema">Validating a Stitched Schema</a></li><li><a href="#customizing-stitching-builder">Customizing Stitching Builder</a></li></ul></li><li><a href="#authentication">Authentication</a></li><li><a href="#batching">Batching</a></li><li><a href="#root-types">Root Types</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/signet.svg" alt="Hot Chocolate" width="64" height="64"/></a><div><h5>Docs</h5><a href="/docs/introduction.html">Quickstart</a><a href="/docs/code-first-introduction.html">Code-First</a><a href="/docs/options.html">General</a></div><div><h5>Examples</h5><a href="/docs/example-star-wars-code-first.html">Star Wars</a></div><div><h5>Community</h5><a href="https://join.slack.com/t/hotchocolategraphql/shared_invite/enQtNTA4NjA0ODYwOTQ0LTBkZjNjZWIzMmNlZjQ5MDQyNDNjMmY3NzYzZjgyYTVmZDU2YjVmNDlhNjNlNTk2ZWRiYzIxMTkwYzA4ODA5Yzg" target="_blank" rel="noreferrer noopener">Join us on Slack</a><a href="https://twitter.com/Chilli_Cream" target="_blank" rel="noreferrer noopener">Follow us on Twitter</a><a href="http://stackoverflow.com/questions/tagged/hotchocolate" target="_blank" rel="noreferrer noopener">Stack Overflow</a></div><div><h5>More</h5><a href="https://chillicream.com/blog" target="_blank">Blog</a><a href="https://github.com/ChilliCream/hotchocolate" target="_blank">GitHub</a><a href="https://github.com/ChilliCream/hotchocolate/issues" target="_blank">Issues</a><a class="github-button" href="https://github.com/ChilliCream/hotchocolate" data-icon="octicon-star" data-count-href="/chillicream/hotchocolate/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2019 <a href="https://chillicream.com" target="_blank">ChilliCream</a></section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>window.twttr=(function(d,s, id){var js,fjs=d.getElementsByTagName(s)[0],t=window.twttr||{};if(d.getElementById(id))return t;js=d.createElement(s);js.id=id;js.src='https://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js, fjs);t._e = [];t.ready = function(f) {t._e.push(f);};return t;}(document, 'script', 'twitter-wjs'));</script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '47d61652587888cd5144dcdd6fb9117b',
                indexName: 'hotchocolate',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["language:en","version:next"]}
              });
            </script></body></html>